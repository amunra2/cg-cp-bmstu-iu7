\chapter{Аналитическая часть}

\section{Водопад как природное явление}

\textbf{Водопад} -- падение воды в реке с уступа, который пересекает речное русло. Не всякий поток воды можно назвать водопадом. Для этого должны соблюдаться несколько важных условий: высота более 1 метра и уклон свыше 45 градусов. 

\imgHeight{60mm}{waterfall_model.jpg}{Модель водопада}

Чаще всего водопады возникают при перепаде высот, которые были там еще до появления реки. 
Также водопады появляются по причине эрозии -- водяной поток размывает мягкие осадочные породы, тем самым происходит обрушение вышележащих слоев породы, вследствие чего на границе твердых и мягких пород образуется вертикальный уступ, с которого падает вода.

При моделировании водопада чаще всего обращают внимание лишь на поток воды, который падает вниз с обрыва. Но для качественной и реалистичной картинки этого не достаточно. При построении модели водопада нужно учитывать три важные его составляющие -- сам поток воды, брызги, которые от него исходят, а также аэрозольное облако, которое образуется при ударе потока об воду.

В процессе моделирования каждая часть будет рассмотрена отдельно, чтобы в конце совместить результаты и получить наиболее реалистичную картинку.


\section{Методы визуализации водопадов}

Водопад представляет собой водяной поток с частицами брызг. За все время моделирования текучей воды было разработано несколько основных методов, конкретнее о которых речь и пойдет дальше.


\subsection{Метод, основанный на уравнении Навье-Стокса}

\textit{Уравнение Навье-Стокса} \cite{navier-stokes} является системой дифференциальных уравнений в частных производных, которое описывает движение вязких ньютоновских жидкостей, которое до сих пор не имеет решения в общем виде. 

\begin{equation}
    \frac{d\vec{v}}{dt} = -(\vec{v}	\bigtriangledown)\vec{v} + \nu \bigtriangleup \vec{v} - \frac{1}{\rho} \bigtriangledown p + \vec{f},
\end{equation}

где $\bigtriangledown$ -- оператор набла, $\bigtriangleup$ -- векторный оператор Лапласа, $t$ -- время, \linebreak $\nu$ -- коэффициент кинематической вязкости, $\rho$ -- плотность, $p$ -- давление, $\vec{v}$ -- векторное поле скорости, $\vec{f}$ -- векторное поле массовых сил.

Уравнение часто используется для математического моделирования сложных моделей природных явлений. При разработке алгоритмов используются частные решения.

Методы, которые строятся на основе этого уравнения, являются довольно трудно реализуемы за счет большого количества сложной математики, с которой приходится работать, а также множества вычислений, которые приходится делать компьютеру при обработке всех формул, что является крайне неэффективным. По этим причинам методы на основе уравнения Навье-Стокса рассматриваться подробно не будут. \cite{navier-stokes-cg}

\subsection{Метод, основанный на частицах}

Метод частиц заключается в использовании трилинейной интерполяции для каждой частицы, чтобы определить ее скорость движения. И каждая частица перемещается в соответствии с определенным инерциальным физическим уравнением. Данный подход имеет довольно небольшие затраты по компьютерным ресурсам, а также большое количество частиц позволяет достичь максимальной точности изображения. Но от количества частиц зависит нагрузка на компьютер. Главным минусом является невозможность точно определить границы, в которых должен находиться водяной поток, что приводит к размещению дополнительных проверок, а также нет возможности создавать извивающиеся водяные потоки.

Наиболее распространённые методы с частицами представлены далее.

\subsubsection{Метод на основе понятия о полу-Лагранже}

Метод на основе понятия о полу-Лагранже, который объединяется с новым подходом расчета жидкости вокруг объектов, позволяет эффективно решать уравнения движения жидкости, сохраняя при этом достаточно деталей, чтобы получить реалистичное изображение. Высококачественная поверхность получается из результирующего поля скоростей с использованием новой адаптивной техники для создания неявной поверхности  \cite{semi-lagrangian-particle}.

\subsubsection{Метод, использующий диаграммы Вороного}

Ключевым компонентом этого алгоритма является аппроксимация геометрии пены путем обработки частиц пузырьков как участков взвешенной диаграммы Вороного. Информация о связности, предоставляемая диаграммой Вороного, позволяет нам точно моделировать различные эффекты взаимодействия между пузырьками.

Пусть $P$ -- точка, заданная в $R^3$. Тогда для любой точки $p$, принадлежащей $P$, ячейка Вороного $V_p$ точки $p$ определяется как место точки в $R^3$, имеющих $p$ в качестве ближайшего соседа в $P$:

\begin{equation}
    V_p = \{x \in R^3, \forall q \in P: |x - p| < |x - q|\}
\end{equation}

Каждая ячейка Вороного -- выпуклая, а граница состоит из выпуклых граней меньшего размера. Совокупность ячеек Вороного и их граней образует комплекс ячеек в $R^3$, что и называется диаграммой Вороного.

Используя ячейки Вороного и веса, также можно явно решить проблему потери объема при моделировании пены, что является общей проблемой во многих подходах. Может быть встроен в симуляторы жидкости, в частности, водопада \cite{voronov-diagram-particle}.

\subsubsection{Метод, использующий уравнения движения частиц по криволинейной траектории}

При моделировании каждая частица считается независимой и для нее вычисляется ее место в соответствии с физическим уравнением. Сами частицы случайным образом распределяются по линии течения воды.

В системе частиц каждая отдельно взятая частица будет рассматриваться в независимости от остальных частиц. В качестве приоритетного подхода к реализации модели частицы, падающей с вершины водопада, используется подход, который основан на криволинейном равноускоренном движении. Данный подход позволяет, используя известные физические законы для движения частицы, получить качественный результат.

\textbf{Для моделирования потока воды} в качестве основного уравнения берется закон равноускоренного движения:

\begin{equation}
    y = y_0 + v_0 t + \frac{a t^2}{2},
\end{equation}

где $y_0$ -- начальное положение частицы, $v_0$ -- начальная скорость движения частицы, $a$ -- ускорение движения частицы, $t$ -- время.

\imgHeight{60mm}{motion_law.png}{Равноускоренное движение}


При этом скорость частицы при равноускоренном движении вычисляется так:

\begin{equation}
    v = v_0 + a t,
\end{equation}

где, $a = const$.

Само ускорение можно вычислить подобным образом:

\begin{equation}
    a = \frac{dv}{dt}
\end{equation}

Тогда основной закон равноускоренного движения можно записать так:

\begin{equation}
    y = y_0 + v_0 t + \frac{v t}{2},
\end{equation}


Также нужно рассмотреть нахождение скорости, в зависимости направления, которое было задано частице. Вектор направления (D) в каждый момент времени вычисляется, путем сложения вектора направления движения и вектора гравитации. При этом получается новый вектор направления -- результирующий вектор, тогда скорость будет вычисляться так:

\begin{equation}
    \vec{v} = v * \vec{R},
\end{equation}

где $\vec{v}$ -- вектор скорости частицы, $v$ -- скалярная скорость частицы, а $\vec{R}$ -- результирующая вектора направления и вектора гравитации.

\imgHeight{60mm}{velocity_find.png}{Результирующий вектор}

\textbf{Водяной пар} моделируется определенным образом. Поскольку при ударе воды о водяную поверхность образуется пар, то его также необходимо смоделировать. Полученная система частиц при реализации основного потока водопада позволяет получить довольно простую реализацию водяного пара.

При достижении водоема, частица отражается, теряя при этом 70\% от скорости, и перекрашивается в белый цвет, обозначая тем самым, что она превратилась в пар. При этом и изменяется направление ее движения, то в векторе направления координата по $z$ умножается на минус один.

\textbf{Водяные брызги} также можно получить из имеющегося водяного потока. Благодаря использованию системы частиц просто смоделировать частицы брызг, которые отходят от водопада. Поскольку каждая частица имеет определенное время жизни (так как частицы, которые прошли стадию водопада и пара должны быть удалены), она при скором достижении конца жизни (примерно на 100 моментов времени меньше, чем максимальное время жизни частицы) перекрашивается в белый, чтобы показать, что она стала брызгом, уменьшается на 30\% скорость, а также у нее изменяются значения вектора направления, умножаясь на определенные коэффициенты, что в данном случае для $y$ координаты равно $1.014$.


\subsection{Сеточные методы}

Сетки часто используются при моделировании жидкостей. В свою очередь, сама сетка -- регулярная кубическая, в каждой ячейке которой содержится информация о точке поверхности, которая задает саму картину. Данный метод при большом количестве ячеек вызывает большое потребление памяти, хотя чем больше ячеек, тем выше качество получаемого изображения. Но также этот метод имеет и  свои преимущества. Во-первых, визуализировать результат симуляции проще. Во-вторых, точно известны границы желаемой области, что приводит к возможности встроить данный водяной поток в нужное место.

Наиболее распространённые методы с сеткой представлены ниже.

\subsubsection{Метод моделирования пузырька воздуха в воде}

Данный метод представляет собой физически обоснованный метод расчета размеров пузырьков воздуха, основанный на скорости замерзания и давлении. В отличие от большинства методов, этот метод может представлять множество мелких пузырьков, которые не могут быть представлены с помощью решений имитационных сеток \cite{bubble-grid};

\subsubsection{Метод, использующий уравнение Эйлера}

В данном методе используется уравнение Эйлера движения невязкой частицы:

\begin{equation}
    \frac{du}{dt} = -(u \cdot \bigtriangledown)u + \frac{f}{\rho} - \frac{\bigtriangledown p}{\rho},
\end{equation}

при этом учитывается ограничение несжимаемости:

\begin{equation}
    \bigtriangledown \cdot u = 0,
\end{equation}

где $u = [u, v, w]^T$ -- поле скорости жидкости, $p$ -- давление, $t$ -- время, $\rho$ -- плотность жидкости, а $f$ -- поле внешних сил.

Благодаря новому подходу можно моделировать крупномасштабные трехмерные жидкости. Здесь используется гибридное представление сетки, состоящее из правильных кубических ячеек поверх слоя высоких ячеек. Также благодаря оптимизации в представлении сетки была предложена реализация ГПУ решателя для жидкости \cite{eiler-equation-grid}.


\subsection{Комбинированный метод}
Методы, основанные на частицах и на сетках, было предложено объединить в один. Совместное их использование помогает одновременно с потоком воды моделировать и другие виды водяных потоков. При создании полноценной системы данный метод является предпочтительным.

Наиболее распространённые комбинированные методы представлены ниже.

\subsubsection{Метод, при котором моделируются пузырьки воздуха и пена вместе}

Метод использует уравнение гидродинамики сглаженных частиц (SPH). В данном методе жидкость превращается в набор частиц $i$ с положением $x_i$ и скоростью $v_i$. Как правило, количество частиц $A_i$ аппроксимируется функцией сглаживания, которая интерполирует $A_i$, используя конечный набор точек выборки $j$, находящихся на расстоянии $h$. Этот набор точек выборки называется \textit{окрестностью частицы}. Функция сглаживания определяется так:

\begin{equation}
    A_i = \sum_j \frac{m_j}{\rho_j} A_j W (x_i - x_j h),
\end{equation}

где $m_j$ -- масса j, $\rho_j$ -- ее плотность, а $W (x_i - x_j, h)$ -- функция ядра (кубический сплайн).

Фазы моделирования пузырьков воздуха и пены рассматриваются отдельно. Также в этом методе применяется такие подходы, как использование силы сопротивления (для того, чтобы совместить оба этапа и при этом сильно не увеличить вычислительные нагрузки), функция насыщения (зависит от объема). При достижении поверхности пузырьки преобразуются в пену, а потом удаляются за указанное пользователем время \cite{sph-combo};

\subsubsection{Метод, который напрямую использует подходы на основе сеток и частиц}

Области жидкости, которые не могут быть представлены полем полем высоты (например, разбивающиеся волны и брызги из-за ударов воды), то они представляются частицами и превращаются в брызги и пену. Сами частицы рассматриваются как простые невзаимодействующие точечные массы, которые обмениваются массой и моментом с жидкостью поля высоты  \cite{real-time-combo}.


\subsection*{Вывод}
В качестве приоритетного выбирается метод, основанный на частицах. Выбор заключается в том, что данный метод предоставляет возможность смоделировать как сам водопад, который представляет из себя большое количество частиц, так и различные брызги и пену, которая также будет являться частицей.


\section{Формализация модели}
Модель водопада будет задаваться такими характеристиками, как:
\begin{itemize} 
    \item высота -- высота уступа, с которого будет падать вода. Число типа $float$ в промежутке от 3 до 30 (в метрах);
    \item ширина -- по сути, ширина уступа, с которого течет вода. Число типа $float$ в промежутке от 1 до 10 (в метрах);
    \item угол падения -- угол, который зависит от уступа, с которого падает водопад; число типа $float$;
    \item скорость водопада -- число типа $float$;
    \item количество частиц -- число типа $int$;
    \item размер частиц -- число типа $int$.
\end{itemize}

Также частью сцены будет являться скала, которая будет задаваться геометрическим объектом -- параллелепипедом. Со скалы должен падать водопад.


\section{Выбор метода рендера изображения}

Рендеринг или отрисовка -- термин в компьютерной графике, обозначающий процесс получения изображения по модели с помощью компьютерной программы.

Основным методом для генерации водопада была выбрана система частиц, которая показывает наилучшие результаты при большом количестве объектов. Программа должна работать быстро, чтобы был виден результат, похожий на поток воды. Для рендера системы частиц не подходит стандартная графическая библиотека, поскольку она не справится с нагрузкой, которая будет на нее возложена. Следовательно, необходимо выбрать API, которое позволит более гибко управлять данными, а также использовать графический ускоритель для рендера изображения. Основными API являются DirectX, Vulkan и OpenGL.

\subsection{DirectX}

\textbf{DirectX} -- это последняя версия собственного API компьютерной графики от Microsoft, используемого для платформ Windows и Xbox. Он нацелен на создание менее сложного драйвера и API, более близкого к архитектуре современных графических процессоров. DirectX фокусируется на рендеринге в реальном времени, поэтому он предназначен для разработчиков игр и систем автоматизированного проектирования (CAD). Поскольку это отраслевой стандарт API компьютерной графики, можно ожидать, что почти все совместимые аппаратные средства будут иметь его надежную поддержку, и он станет стандартом для коммерческих проектов.

Этапы рендеринга растровой графики с помощью DirectX очень похожи на этапы других современных графических API. 

\begin{enumerate}
    \item \textit{Инициализация API} — создаются:

    \begin{itemize}
        \item фабрика -- точка входа в DirectX API;
        \item адаптер -- предоставляет информацию о физических характеристиках данного устройства DirectX;
        \item устройство -- основная точка входа в DirectX API, предоставляющая доступ к внутренним частям API. Это ключ к важным структурам данных, таким как конвейеры, шейдеры, состояние рендеринга;
        \item очередь команд -- позволяет отправлять группы вызовов отрисовки, известных как списки команд, для выполнения по порядку, что позволяет графическому процессору оставаться занятым и оптимизировать скорость его работы;
        \item распределитель команд -- используется для создания списка команд, то есть структуры данных, в которой выполняются вызовы отрисовки к GPU.
    \end{itemize}
    \item \textit{Инициализация ресурсов} — создаются:
    \begin{itemize}
        \item буфер вершин -- хранит информацию о каждой вершине, доступную в виде атрибутов в вершинном шейдере;
        \item индексный буфер -- содержит индивидуальные индексы каждых треугольника/линии/точки, которые нужно нарисовать;
        \item однородный буфер -- описывает данные, которые будут посылаться во время отрисовки к стадиям шейдеров (например, цвет).
    \end{itemize}
    \item \textit{Визуализация} — обновление однородных данных, добавление команд в очередь и ожидание следующего кадра.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокое качество изображения;
    \item быстрый рендер изборажения.
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item новые версии только для самого современного оборудования (не поддерживается старыми видеокартами);
    \item используется только на Windows.
\end{itemize}


\subsection{OpenGL}

OpenGL -- в большинстве случаев рассматривается как API, предоставляющий большой набор функций, которые можно использовать для управления графикой и изображениями. OpenGL является спецификацией, разработанной и поддерживаемой Khronos Group.

Спецификация OpenGL определяет, каким должен быть результат/вывод каждой функции, и как она должна выполняться. А вот реализация этой спецификации уже зависит от конкретных разработчиков.

Если не ограничиваться аппаратурой, а рассмотреть поддержку графической обработки для современных систем в целом, то видно, что она базируется на понятии конвейера: графические данные проходят последовательно несколько этапов обработки -- выходные данные одного этапа сразу передаются на вход следующего. Абстрагируясь от связанных с конкретными реализациями деталей, можно рассмотреть универсальный графический конвейер и выделить в нем 5 этапов.

\begin{enumerate}
    \item Этап генерации (G) -- создание и модификация прикладных структур данных.
    \item Этап обхода (T) прикладных структур данных и порождение соответствующих графических данных.
    \item Этап преобразования (X), на котором графические данные из системы координат объекта преобразуются в систему координат наблюдателя, выполняется расчет освещенности, отсечение преобразованных данных, а затем проецирование результата в пространство окна.
    \item На этапе растеризации (R) создаются и записываются в буфер кадра дискретные образы примитивов: точки, отрезки и полигоны. Буфер кадра -- это банк памяти, предназначенный для хранения массива пикселей изображения. На этом этапе для всех вершин геометрических объектов вычисляется закраска, производится наложение определенных участков текстуры, а также выполняются пиксельные операции, такие, например, как сравнение по глубине.
    \item На этапе вывода (D) происходит сканирование буфера кадра и вывод изображения на экран дисплея.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокая производительность работы;
    \item гибкая структура, которая позволяет изменять параметры выводимых объектов;
    \item кроссплатформенность (используется на Linux, MacOS, Windows);
    \item библиотеки для работы с API на различных языках программирования.
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item сложная работа с новыми возможностями GPU;
    \item не имеет возможности для работы с мышью и клавиатурой (нужно отдельное API).
\end{itemize}


\subsection{Vulkan}

Vulkan — кроссплатформенный API для 2D- и 3D-графики, представленный Khronos Group.

Vulkan API изначально был известен как <<новое поколение OpenGL>> или просто <<glNext>>, но после анонса компания отказалась от этих названий в пользу названия Vulkan. Как и OpenGL, Vulkan позволяет с высокой производительностью отображать в реальном времени различные приложения с 3D-графикой, такие как игры или интерактивные книги на всех платформах, а также обеспечивает более высокую производительность и меньшую нагрузку на процессор.

Перед получением изображения на экран, Vulkan выполняет ряд следующих действий.

\begin{enumerate}
    \item \textbf{Подготовка}. Нужно сообщить Vulkan, какие буферы будут использоваться во время рендеринга. Необходимо указать, сколько будет буферов цвета, буферов глубины. Также нужно указать, как должно обрабатываться содержимое буферов во время рендеринга. Вся эта информация обернута в объект прохода рендера.
    \item \textbf{Настройка буферов}. Настраиваются буферы глубины и цвета, в которые загружаются данные. При конфигурации используются два основных метода, для каждого буфера: \textit{loadOp} и \textit{storeOp}. Для \textit{loadOp} возможны следующие значения:
    \begin{itemize}
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_LOAD} -- буфер будет содержать те данные, которые были помещены в него до этого прохода (например, во время предыдущего прохода);
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_CLEAR} -- буфер очищается в начале прохода рендера;
        \item \textit{VK\_ATTACHMENT\_LOAD\_OP\_DONT\_CARE} -- содержимое буфера не определено.
    \end{itemize}

    Для \textit{storeOp} возможны два значения:
    \begin{itemize}
        \item \textit{VK\_ATTACHMENT\_STORE\_OP\_STORE} -- содержимое буфера сохраняется в память для дальнейшего использования;
        \item \textit{VK\_ATTACHMENT\_STORE\_OP\_DONT\_CARE} -- после рендеринга буфер больше не используется, и его содержимое не имеет значения.
    \end{itemize}
    \item \textbf{Подпроходы}. Один проход рендера может состоять из множества подпроходов. Подпроходы -- это последовательные операции рендеринга, зависящие от содержимого фреймбуферов в предыдущих проходах. К ним относятся, например, эффекты постобработки, применяемые друг за другом. Если объединить их в один проход рендера, Vulkan сможет перегруппировать операции для лучшего сохранения пропускной способности памяти и большей производительности. Каждый подпроход ссылается на один или несколько буферов.
    \item \textbf{Проход рендера}. Вывод изображения на экран дисплея.
\end{enumerate}


\textbf{Преимущества:} 
\begin{itemize}
    \item высокая производительность работы;
    \item открытый код;
    \item кроссплатформенность (используется на Linux, MacOS, Windows).
\end{itemize}

\textbf{Недостатки:} 
\begin{itemize}
    \item работа на глубоком уровнем GPU;
    \item не имеет библиотек, позволяющих полноценно использовать Vulkan на другом языке.
\end{itemize}


\subsection*{Вывод}

Проанализировав различные API для рендера изображения на экран, был выбран OpenGL. Он отличается кроссплатформенностью, что дает ему выигрыш над DirectX, потому что DirectX используется исключительно для операционных систем Windows. Также Vulkan не имеет библиотек для языка программирования Python, которые предоставляли бы весь функционал API Vulkan. Следовательно, OpenGL выбран в качестве приоритетного метода для рендера изображения системы частиц водопада. 


% \section{Выбор алгоритма удаления невидимых ребер и поверхностей}
% Для начала выделим несколько свойств, которыми должен обладать выбранный алгоритм, чтобы обеспечить оптимальную работу и реалистичное изображение.

% Свойства:
% \begin{itemize} 
%     \item алгоритм может работать как в объектном пространстве, так и в пространстве изображений;
%     \item алгоритм должен быть достаточно быстрым и использовать мало памяти.
% \end{itemize}


% \subsection{Алгоритм, использующий Z-буфер}
% \textit{Суть данного алгоритма} -- это использование двух буферов: буфера кадра, в котором хранятся атрибуты каждого пикселя, и Z-буфера, в котором хранятся информация о координате Z для каждого пикселя.

% Изначально в Z-буфере находятся минимальные значения Z, а в буфере кадра -- информация о пикселях, которые описывают фон. Глубина каждого нового пикселя при подсчете сравнивается со значением, которое уже есть в Z-буфере. В случае, если новый пиксель расположен ближе к наблюдателю, чем предыдущий, то информация о нем заносится в буфер кадра и происходит редактирование Z-буфера.

% \textit{Положительной стороной} данного алгоритма является простота реализация, экономия времени, так как нет сортировки.

% \textit{Недостатком} -- большой объем требуемой памяти, а также сложная реализация эффектов прозрачности.


% \subsection{Алгоритм обратной трассировки лучей}
% \textit{Суть данного алгоритма} состоит в том, что наблюдатель видит объект с помощью испускаемого света, который согласно законам оптики доходит до наблюдателя некоторым путем. Алгоритм называется “обратной трассировкой” из-за того, что эффективнее выходит отслеживать лучи, которые идут от наблюдателя к объекту.

% \textit{Положительным моментом} в этом алгоритме является возможность использования в параллельных вычислительных системах.

% \textit{Недостатком} же является то, что требуется большое количество необходимых вычислений.


% \subsection{Алгоритм Робертса}
% Данный алгоритм решает задачу удаления невидимых ребер и граней только с выпуклыми телами, работает только в объектном пространстве.

% У алгоритма три этапа выполнения:

% \begin{itemize} 
%     \item этап 0 -- подготовка данных; 
%     \item этап 1 -- удаление ребер, экранируемых самим телом; 
%     \item этап 2 -- удаление невидимых ребер, экранируемых другими телами сцены.
% \end{itemize}  

% \textit{Положительным моментом} в этом алгоритме является высокая точность вычислений. 

% \textit{Недостатком} же является то, что все тела должны быть выпуклыми.

% \subsection{Алгоритм художника}
% Данный алгоритм работает аналогично тому, как художник рисует картину -- то есть сначала рисуются дальние объекты, а затем более близкие. Наиболее распространенная реализация алгоритма -- сортировка по глубине, которая заключается в том, что произвольное множество граней сортируется по ближнему расстоянию от наблюдателя, а затем отсортированные грани выводятся на экран в порядке от самой дальней до самой ближней. Данный метод работает лучше для построения сцен, в которых отсутствуют пересекающиеся грани. 

% \textit{Положительным моментом} является то, что данный алгоритм требует памяти меньше, чем, например, алгоритм Z-буфера.

% \textit{Недостатком} же является то, что у него недостаточно высока реалистичность изображения.

% \subsection*{Вывод}
% Для удаления невидимых линий выбран алгоритм Z-буфера. Данный алгоритм довольно прост в реализации, работает довольно быстро из-за отсутствия сортировок, а также позволяет добиться хорошей реалистичности, что очень важно при моделировании таких  явлений природы, как водопад.
 

\section{Существующие программные обеспечения}
\textit{Blender} -- бесплатный, кроссплатформенный набор инструментов для работы с 3D с открытым кодом. Он обладает широким функционалом: подходит для моделирования, симуляции, рендеринга, монтажа, записи видео и создания игр.

Благодаря огромному количеству аддонов, которые создают сами пользователи, можно смоделировать практически все, что угодно. Это относится и к водопаду, который можно пустить по любой поверхности, при этом это будет выглядеть максимально реалистично.

На фотографиях ниже представлен пример такого водопада.
\imgHeight{60mm}{waterfall_example1.jpg}{Пример реализации водопада в программе Blender ч.1}
\imgHeight{60mm}{waterfall_example2.jpg}{Пример реализации водопада в программе Blender ч.2}
\imgHeight{60mm}{waterfall_example3.jpg}{Пример реализации водопада в программе Blender ч.3}
\imgHeight{60mm}{waterfall_example4.jpg}{Пример реализации водопада в программе Blender ч.4}
\clearpage

\section*{Вывод}

В данном разделе были формально описаны все методы по визуализации текучей воды, с помощью которых можно получить реализацию водопада, а также методы рендера изображения. В качестве алгоритма визуализации водопада предпочтение отдается методу, который реализует подход, основанный на системе частиц. Также OpenGL был выбран в качестве метода рендера изображения.

% В данном разделе были формально описаны все методы по визуализации текучей воды, с помощью которых можно получить реализиацию водопада, а также методы удаления невидимых линий и поверхностей и закрашивания областей. В качестве алгоритма визуализации водопада предпочтение отдается методу, который реализует подход, основанный на системе частиц. В качестве алгоритма удаления невидимых линий и областей -- z-буфер.
